\section{Multi-way particle swarm fusion}
Multi-way Particle Swarm Fusion is a natural extension of Fusion Move
method (FM). We call our method Swarm Fusion (SF) in short. Take a
multi-threading environment to explain our idea, while the technique is
also applicable to other parallel programming model such as {\it
MapReduce} in cloud computing.
%

Assuming we have $N$ threads $\{T_i | i=1, 2, \cdots, N\}$, each thread
$T_i$ maintains and updates a solution $S_i$ in parallel. Alpha
expansion picks one label in each iteration to perform fusion. FM
invokes one proposal generation scheme and generates a solution proposal
for fusion. Swarm Fusion has 1) a {\it proposal pool}, from which we
pick arbitrary number of proposal generation schemes and generate
proposals, and 2) a {\it solution pool}, from which we pick arbitrary
number of intermediate solutions generated by all the other threads.
%
% Traditional FM has a set of proposal generation schemes to be
% invoked
%
% There are two places to
% collect solutions or solution proposals for fusion. First, the {\it
% proposal pool} can generate new solution proposals on request.
% %
% Second, the {\it solution pool} stores the solutions that have been
% fused by the threads.
In our base configuration, the solution pool only remembers one (the
best) solution generated by each thread.

Swarm Fusion has two main parameters $\alpha_i$ and $\beta_i$ (for each
thread $T_i$), determining the processing flow of the algorithm: In each
fusion step, the thread collects $\alpha_i$ solution proposals from the
proposal pool and $\beta_i$ solutions from the solution pool, following
a user-defined strategy or at random to be simple.
%
% One can further customize how to pick certain proposal generation
% schemes (as in ~\cite{delong}) or solutions.
Swarm Fusion framework is very flexible and yields various data
processing architectures as shown in Figure~\ref{fig:model}.
%
\begin{figure}[tb]
 \includegraphics[width=\columnwidth]{figure/model.pdf} \caption{Swarm
 Fusion architecture and its relationships to existing methods. mention
 that hierarchical fusion works in a different way, but we can still
 consider that to be our special case, by letting each thread not using
 its own solution in the next fusion.}\label{fig:model}
\end{figure}
%
The bottom right configuration is the most general one, in which we
always fuse some solution proposals and some concurrent solutions
(i.e., $\alpha\ne 0, \beta \ne 0$).
%
Each fusion is multi-way (not binary) with a non-submodular energy, and
we use TRW~\cite{kolmogorov} for the fusion, while any other compatible
inference techniques can be used~\cite{opengm}. Of course, if one knows
that a certain fusion step is a binary fusion with submodular energy,
one can use graph-cuts instead~\cite{alpha_expansion_paper}. If a
certain fusion step is a binary fusion with non-submodular energy, one
can use QPBO~\cite{second_order_smoothness_stereo}.
%
Note that the threads are all synchronized in the figure for a
illustration purpose. In practice, all the threads run asynchronously
with a (read-write) lock on the data in the two pools (See Algorithm~\ref{algorithm:sf}).
%The asynchronous processing could be difficult for cloud parallel
%computing.
%
%
%
\begin{algorithm}
 \caption{Swarm Fusion method}
 \label{algorithm:sf}
 \begin{algorithmic}
  %\Procedure{Swarm Fusion method} {}
  \Procedure{} {$\alpha, \beta$}
  \State $\mathcal{S}_{pool} \leftarrow \emptyset$ //
  Solution pool
  \State Initialize $\mathcal{P}_{pool}$ // Proposal pool
  \ForEach{thread $T_i$}
  \State Initialize its solution $S_i$
  \EndFor
  \State
  \ForEach{thread $T_i$ in parallel till convergence}
  \State Pick $\alpha$ solution proposals $\mathcal{P}\subset \mathcal{P_{\mbox{pool}}}$
  \State Pick $\beta$ solutions $\mathcal{S} \subset \mathcal{S_{\mbox{pool}}}$
  \State $S_i \leftarrow \mbox{Fuse}(S_i, \mathcal{P}, \mathcal{S})$
  \State Replaces the solution in $\mathcal{S}_{pool}$ with $S_i$
  \State [ Generates proposals and update $\mathcal{P}_{pool}$ ]
  \EndFor
  \EndProcedure
 \end{algorithmic}
\end{algorithm}


\mysubsubsubsection{Relationships to existing methods}

\noindent It is easy to verify that alpha-expansion
(AE)~\cite{alpha_expansion}, fusion move (FM)~\cite{viktor}, parallel
alpha-expansion (PAE)~\cite{delong}, and hierarchical fusion
(HF)~\cite{delong_hierarchical,olga} are all special cases of the Swarm
Fusion method.~\footnote{The hierarchical fusion has a slightly
different data processing model, without strong ties between threads
data, but this can be considered as a special case of SF by not using
$S_i$ in each fusion step of $T_i$.} For example, AE can be realized by
setting $\alpha=1, \beta=0$ and restricting the proposal generation to
constant labels with a single thread. Same goes for FM, this time,
without the restriction on the proposal generation scheme. PAE is
realized by setting $\alpha=1,\beta=1$ with multiple threads, again with
a restriction on the proposal generation scheme. The last sequential
fusion (at the top of the diagram in the figure) can be modeled by
changing to $\alpha=0, \beta=1$ with a single thread.


% The swarm fusion is highly flexible, and we first introduce our base
% architecture that exploits general strenghts offered by the
% framework. Later, we explain how to further optimize the configuration
% to boost performance for specific problems. In the base architecture,
% all the threads fuse some number of proposals from the proposal pool and
% some number of solutions from the solution pool in each step. In other
% words, all the threads constantly exchange solutions while injecting new
% proposals. This architecture is illustrated in Figure~\ref{fig:model}.


% \begin{figure}[tb]
%  \includegraphics[width=\columnwidth]{figure/model2.pdf}
%  \caption{Base Swarm Fusion architecture.}\label{fig:base}
% \end{figure}

% \mysubsubsection{Relationships to existing methods} Our framework is
% general, and it is easy to verify that existing parallel fusion
% algorithms are just our special cases.
%
% For example, the parallel fusion algorithm by Lempitsky et
% al.~\cite{viktor} always performs binary fusion between the current
% solution and another label, which can be achieved by setting $\alpha_i =
% 1$ and $\beta_i = 0$ for all the threads. The algorithm by
% Veksler~\cite{olga} or Dejong et al.~\cite{dejong} hierarchically fuses
% solutions starting from solution proposals. The algorithm can be
% realized by setting $\alpha_i = 1, \beta_i = 0$ initially, then use
% $\alpha_i = 0, \beta_i=1$  for the rest of the algorithm.

% \noindent
% We now illustrate the power of Swarm Fusion framework for three problems
% in Computer Vision. 


% Suppose $N=4$, $\alpha_1 = 2$, and $\beta_1 = 3$. In this
% configuration, the first thread $T_1$ fuses its current solution $S_1$,
% two new proposal solutions (e.g., by randomly picking two proposal
% generation schemes), and the current solutions $(S_2, S_3, S_4)$ in the
% other three threads. This is a multi-way fusion with a non-submodular
% energy in general, and message passing algorithm such as
% TRW~\cite{kolmogorov} can be used. Sequential QPBO application is
% another.


% Our model is flexible. For example, a parallel fusion move algorithm by
% Lempitsky et al.~\cite{viktor} is a special case of ours, where $\alpha_i$

% , and it is easy to see that 
% Existing parallel fusion techniques are special 

% Our model is flexible and 
